"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makePlugin = void 0;
const babel_import_util_1 = require("babel-import-util");
const expression_parser_1 = require("./expression-parser");
const js_utils_1 = require("./js-utils");
const scope_locals_1 = require("./scope-locals");
const syntax_1 = require("@glimmer/syntax");
__exportStar(require("./public-types"), exports);
const INLINE_PRECOMPILE_MODULES = [
    {
        moduleName: 'ember-cli-htmlbars',
        export: 'hbs',
        allowTemplateLiteral: true,
    },
    {
        moduleName: 'ember-cli-htmlbars-inline-precompile',
        export: 'default',
        allowTemplateLiteral: true,
    },
    {
        moduleName: 'htmlbars-inline-precompile',
        export: 'default',
        allowTemplateLiteral: true,
    },
    {
        moduleName: '@ember/template-compilation',
        export: 'precompileTemplate',
        enableScope: true,
    },
    {
        moduleName: '@ember/template-compiler',
        export: 'template',
        enableScope: true,
        rfc931Support: 'polyfilled',
    },
];
function normalizeOpts(options) {
    var _a;
    if (((_a = options.targetFormat) !== null && _a !== void 0 ? _a : 'wire') === 'wire') {
        let { compiler } = options;
        if (!compiler) {
            throw new Error(`when targetFormat==="wire" you must set the compiler or compilerPath option`);
        }
        return Object.assign(Object.assign({ outputModuleOverrides: {}, enableLegacyModules: [], transforms: [] }, options), { targetFormat: 'wire', compiler });
    }
    else {
        return Object.assign(Object.assign({ outputModuleOverrides: {}, enableLegacyModules: [], transforms: [] }, options), { targetFormat: 'hbs' });
    }
}
function makePlugin(loadOptions) {
    return function htmlbarsInlinePrecompile(babel) {
        let t = babel.types;
        const plugin = {
            visitor: {
                Program: {
                    enter(path, state) {
                        state.normalizedOpts = normalizeOpts(loadOptions(state.opts));
                        state.templateFactory = templateFactoryConfig(state.normalizedOpts);
                        state.util = new babel_import_util_1.ImportUtil(babel, path);
                        state.program = path;
                        state.recursionGuard = new Set();
                    },
                    exit(_path, state) {
                        if (state.normalizedOpts.targetFormat === 'wire') {
                            for (let { moduleName, export: exportName } of configuredModules(state)) {
                                state.util.removeImport(moduleName, exportName);
                            }
                        }
                    },
                },
                TaggedTemplateExpression(path, state) {
                    let tagPath = path.get('tag');
                    if (!tagPath.isIdentifier()) {
                        return;
                    }
                    let config = referencesInlineCompiler(tagPath, state);
                    if (!config) {
                        return;
                    }
                    if (!config.allowTemplateLiteral) {
                        throw path.buildCodeFrameError(`Attempted to use \`${tagPath.node.name}\` as a template tag, but it can only be called as a function with a string passed to it: ${tagPath.node.name}('content here')`);
                    }
                    if (path.node.quasi.expressions.length) {
                        throw path.buildCodeFrameError('placeholders inside a tagged template string are not supported');
                    }
                    let template = path.node.quasi.quasis.map((quasi) => quasi.value.cooked).join('');
                    if (state.normalizedOpts.targetFormat === 'wire') {
                        insertCompiledTemplate(babel, state, state.normalizedOpts, template, path, {}, config, undefined);
                    }
                    else {
                        insertTransformedTemplate(babel, state, template, path, {}, config, undefined);
                    }
                },
                CallExpression(path, state) {
                    let calleePath = path.get('callee');
                    if (!calleePath.isIdentifier()) {
                        return;
                    }
                    let config = referencesInlineCompiler(calleePath, state);
                    if (!config) {
                        return;
                    }
                    if (state.recursionGuard.has(path.node)) {
                        return;
                    }
                    if (path.get('arguments').length > 2) {
                        throw path.buildCodeFrameError(`${calleePath.node.name} can only be invoked with 2 arguments: the template string and any static options`);
                    }
                    let [firstArg, secondArg] = path.get('arguments');
                    let template;
                    switch (firstArg === null || firstArg === void 0 ? void 0 : firstArg.node.type) {
                        case 'StringLiteral':
                            template = firstArg.node.value;
                            break;
                        case 'TemplateLiteral':
                            if (firstArg.node.expressions.length) {
                                throw path.buildCodeFrameError('placeholders inside a template string are not supported');
                            }
                            else {
                                template = firstArg.node.quasis.map((quasi) => quasi.value.cooked).join('');
                            }
                            break;
                        case 'TaggedTemplateExpression':
                            throw path.buildCodeFrameError(`tagged template strings inside ${calleePath.node.name} are not supported`);
                        default:
                            throw path.buildCodeFrameError(`${calleePath.node.name} should be invoked with at least a single argument (the template string)`);
                    }
                    let userTypedOptions;
                    let backingClass;
                    if (!secondArg) {
                        userTypedOptions = {};
                    }
                    else {
                        if (!secondArg.isObjectExpression()) {
                            throw path.buildCodeFrameError(`${calleePath.node.name} can only be invoked with 2 arguments: the template string, and any static options`);
                        }
                        userTypedOptions = new expression_parser_1.ExpressionParser(babel).parseObjectExpression(calleePath.node.name, secondArg, config.enableScope, Boolean(config.rfc931Support));
                        if (config.rfc931Support && userTypedOptions.component) {
                            backingClass = userTypedOptions.component;
                        }
                    }
                    if (state.normalizedOpts.targetFormat === 'wire') {
                        insertCompiledTemplate(babel, state, state.normalizedOpts, template, path, userTypedOptions, config, backingClass);
                    }
                    else {
                        insertTransformedTemplate(babel, state, template, path, userTypedOptions, config, backingClass);
                    }
                },
            },
        };
        return {
            pre(file) {
                // run our processing in pre so that imports for gts
                // are kept for other plugins.
                babel.traverse(file.ast, plugin.visitor, file.scope, this);
            },
            visitor: {},
        };
    };
}
exports.makePlugin = makePlugin;
function* configuredModules(state) {
    for (let moduleConfig of INLINE_PRECOMPILE_MODULES) {
        if (moduleConfig.moduleName !== '@ember/template-compilation' &&
            moduleConfig.moduleName !== '@ember/template-compiler' &&
            !state.normalizedOpts.enableLegacyModules.includes(moduleConfig.moduleName)) {
            continue;
        }
        yield moduleConfig;
    }
}
function referencesInlineCompiler(path, state) {
    for (let moduleConfig of configuredModules(state)) {
        if (path.referencesImport(moduleConfig.moduleName, moduleConfig.export)) {
            return moduleConfig;
        }
    }
    return undefined;
}
function runtimeErrorIIFE(babel, replacements) {
    let statement = babel.template(`(function() {\n  throw new Error('ERROR_MESSAGE');\n})();`)(replacements);
    return statement.expression;
}
function buildScopeLocals(userTypedOptions, formatOptions, target) {
    if (formatOptions.rfc931Support && userTypedOptions.eval) {
        return new scope_locals_1.ScopeLocals({ mode: 'implicit', jsPath: target });
    }
    else if (userTypedOptions.scope) {
        return userTypedOptions.scope;
    }
    else {
        return new scope_locals_1.ScopeLocals({ mode: 'explicit' });
    }
}
function buildPrecompileOptions(babel, target, state, template, userTypedOptions, config, scope) {
    let jsutils = new js_utils_1.JSUtils(babel, state, target, scope.add.bind(scope), state.util);
    let meta = Object.assign({ jsutils }, userTypedOptions === null || userTypedOptions === void 0 ? void 0 : userTypedOptions.meta);
    let output = {
        contents: template,
        // we've extended meta to add jsutils, but the types in @glimmer/syntax
        // don't account for extension
        meta: meta,
        // TODO: embroider's template-compiler allows this to be overriden to get
        // backward-compatible module names that don't match the real name of the
        // on-disk file. What's our plan for migrating people away from that?
        moduleName: state.filename,
        // This is here so it's *always* the real filename. Historically, there is
        // also `moduleName` but that did not match the real on-disk filename, it
        // was the notional runtime module name from classic ember builds.
        filename: state.filename,
        plugins: {
            // the cast is needed here only because our meta is extended. That is,
            // these plugins can access meta.jsutils.
            ast: [...state.normalizedOpts.transforms, scope.crawl()],
        },
    };
    for (let [key, value] of Object.entries(userTypedOptions)) {
        if (key !== 'scope') {
            // `scope` in the user-facing API becomes `locals` in the low-level
            // ember-template-compiler API
            output[key] = value;
        }
    }
    output.locals = scope.locals;
    if (config.rfc931Support) {
        output.strictMode = true;
    }
    return output;
}
function remapAndBindIdentifiers(target, babel, scopeLocals) {
    target.traverse({
        Identifier(path) {
            var _a;
            if (scopeLocals.has(path.node.name) && path.node.name !== scopeLocals.get(path.node.name)) {
                // this identifier has different names in hbs vs js, so we need to
                // replace the hbs name in the template compiler output with the js
                // name
                path.replaceWith(babel.types.identifier(scopeLocals.get(path.node.name)));
            }
            // this is where we tell babel's scope system about the new reference we
            // just introduced. @babel/plugin-transform-typescript in particular
            // cares a lot about those references being present.
            (_a = path.scope.getBinding(path.node.name)) === null || _a === void 0 ? void 0 : _a.reference(path);
        },
    });
}
function insertCompiledTemplate(babel, state, opts, template, target, userTypedOptions, config, backingClass) {
    let t = babel.types;
    let scopeLocals = buildScopeLocals(userTypedOptions, config, target);
    let options = buildPrecompileOptions(babel, target, state, template, userTypedOptions, config, scopeLocals);
    let precompileResultString;
    // insertRuntimeErrors is legacy and not supported by the newer rfc931 form
    if (options.insertRuntimeErrors && !config.rfc931Support) {
        try {
            precompileResultString = opts.compiler.precompile(template, options);
        }
        catch (error) {
            target.replaceWith(runtimeErrorIIFE(babel, { ERROR_MESSAGE: error.message }));
            return;
        }
    }
    else {
        precompileResultString = opts.compiler.precompile(template, options);
    }
    let templateExpression = babel.template.expression.ast(precompileResultString);
    t.addComment(templateExpression, 'leading', `\n  ${template.replace(/\*\//g, '*\\/')}\n`, 
    /* line comment? */ false);
    state.util.replaceWith(target, (i) => {
        var _a;
        let templateFactoryIdentifier = i.import(state.templateFactory.moduleName, state.templateFactory.exportName);
        let expression = t.callExpression(templateFactoryIdentifier, [templateExpression]);
        if (config.rfc931Support) {
            expression = t.callExpression(i.import('@ember/component', 'setComponentTemplate'), [
                expression,
                (_a = backingClass === null || backingClass === void 0 ? void 0 : backingClass.node) !== null && _a !== void 0 ? _a : t.callExpression(i.import('@ember/component/template-only', 'default', 'templateOnly'), []),
            ]);
        }
        return expression;
    });
    remapAndBindIdentifiers(target, babel, scopeLocals);
}
function insertTransformedTemplate(babel, state, template, target, userTypedOptions, formatOptions, backingClass) {
    let t = babel.types;
    let scopeLocals = buildScopeLocals(userTypedOptions, formatOptions, target);
    let options = buildPrecompileOptions(babel, target, state, template, userTypedOptions, formatOptions, scopeLocals);
    let ast = (0, syntax_1.preprocess)(template, Object.assign(Object.assign({}, options), { mode: 'codemod' }));
    let transformed = (0, syntax_1.print)(ast, { entityEncoding: 'raw' });
    if (target.isCallExpression()) {
        updateCallForm(target, transformed, formatOptions, scopeLocals, state, babel, backingClass);
    }
    else {
        updateBacktickForm(scopeLocals, state, target, t, transformed, babel);
    }
}
function updateBacktickForm(scopeLocals, state, target, t, transformed, babel) {
    if (scopeLocals.isEmpty()) {
        // simple case: just replace the string literal part with the transformed
        // template contents
        target.get('quasi').get('quasis.0').replaceWith(t.templateElement({ raw: transformed }));
        return;
    }
    // need to add scope, so need to replace the backticks form with a call
    // expression to precompileTemplate
    maybePruneImport(state.util, target.get('tag'));
    let newCall = state.util.replaceWith(target, (i) => t.callExpression(precompileTemplate(i), [t.stringLiteral(transformed)]));
    updateScope(babel, newCall, scopeLocals);
}
function updateCallForm(target, transformed, formatOptions, scopeLocals, state, babel, backingClass) {
    // first the simple part: replacing the string literal with the actual body of
    // the rewritten template
    target.get('arguments.0').replaceWith(babel.types.stringLiteral(transformed));
    if (!formatOptions.enableScope && !scopeLocals.isEmpty()) {
        // an AST transform added lexically scoped values to a template that
        // wasn't already in a form that supports them, so convert form.
        maybePruneImport(state.util, target.get('callee'));
        state.util.replaceWith(target.get('callee'), (i) => precompileTemplate(i));
    }
    if (formatOptions.rfc931Support === 'polyfilled') {
        maybePruneImport(state.util, target.get('callee'));
        state.util.replaceWith(target.get('callee'), (i) => precompileTemplate(i));
        convertStrictMode(babel, target);
        removeEvalAndScope(target);
        target.node.arguments = target.node.arguments.slice(0, 2);
        state.recursionGuard.add(target.node);
        state.util.replaceWith(target, (i) => {
            var _a;
            return babel.types.callExpression(i.import('@ember/component', 'setComponentTemplate'), [
                target.node,
                (_a = backingClass === null || backingClass === void 0 ? void 0 : backingClass.node) !== null && _a !== void 0 ? _a : babel.types.callExpression(i.import('@ember/component/template-only', 'default', 'templateOnly'), []),
            ]);
        });
        // we just wrapped the target callExpression in the call to
        // setComponentTemplate. Adjust `target` back to point at the
        // precompileTemplate call for the final updateScope below.
        //
        target = target.get('arguments.0');
    }
    // We deliberately do updateScope at the end so that when it updates
    // references, those references will point to the accurate paths in the
    // final AST.
    updateScope(babel, target, scopeLocals);
}
function templateFactoryConfig(opts) {
    var _a;
    let moduleName = '@ember/template-factory';
    let exportName = 'createTemplateFactory';
    let overrides = (_a = opts.outputModuleOverrides[moduleName]) === null || _a === void 0 ? void 0 : _a[exportName];
    return overrides
        ? { exportName: overrides[0], moduleName: overrides[1] }
        : { exportName, moduleName };
}
function buildScope(babel, locals) {
    let t = babel.types;
    return t.arrowFunctionExpression([], t.objectExpression(locals
        .entries()
        .map(([name, identifier]) => t.objectProperty(t.identifier(name), t.identifier(identifier), false, true))));
}
// this is responsible both for adjusting the AST for our scope argument *and*
// ensuring that babel's scope system will see that these new identifiers
// reference their bindings. @babel/plugin-transform-typescript in particular
// cares an awful lot about whether an import has valid non-type references, so
// these newly introducd references need to be valid.
function updateScope(babel, target, locals) {
    let t = babel.types;
    let secondArg = target.get('arguments.1');
    if (secondArg) {
        let scope = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'scope';
        });
        if (scope) {
            if (locals.isEmpty()) {
                scope.remove();
            }
            else {
                scope.set('value', buildScope(babel, locals));
                // funny-looking naming here, but it actually makes sense because we're
                // connecting the glimmer scope system with the babel scope system.
                scope.scope.crawl();
            }
        }
        else if (!locals.isEmpty()) {
            secondArg.pushContainer('properties', t.objectProperty(t.identifier('scope'), buildScope(babel, locals)));
            secondArg.get(`properties.${secondArg.node.properties.length - 1}`).scope.crawl();
        }
    }
    else if (!locals.isEmpty()) {
        target.pushContainer('arguments', t.objectExpression([t.objectProperty(t.identifier('scope'), buildScope(babel, locals))]));
        target.get('arguments.1').scope.crawl();
    }
}
function removeEvalAndScope(target) {
    let secondArg = target.get('arguments.1');
    if (secondArg) {
        let evalProp = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'eval';
        });
        if (evalProp) {
            evalProp.remove();
        }
        let componentProp = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'component';
        });
        if (componentProp) {
            componentProp.remove();
        }
    }
}
// Given a call to template(), convert its "strict" argument into
// precompileTemplate's "strictMode" argument. They differ in name and default
// value.
function convertStrictMode(babel, target) {
    let t = babel.types;
    let secondArg = target.get('arguments.1');
    if (secondArg) {
        let strict = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'strict';
        });
        if (strict) {
            strict.set('key', t.identifier('strictMode'));
        }
        else {
            secondArg.pushContainer('properties', t.objectProperty(t.identifier('strictMode'), t.booleanLiteral(true)));
        }
    }
    else {
        target.pushContainer('arguments', t.objectExpression([t.objectProperty(t.identifier('strictMode'), t.booleanLiteral(true))]));
    }
}
function maybePruneImport(util, identifier) {
    if (!identifier.isIdentifier()) {
        return;
    }
    let binding = identifier.scope.getBinding(identifier.node.name);
    if (!binding) {
        return;
    }
    let found = binding.referencePaths.find((path) => path.node === identifier.node);
    if (!found) {
        return;
    }
    binding.referencePaths.splice(binding.referencePaths.indexOf(found), 1);
    binding.references--;
    if (binding.references === 0) {
        let specifier = binding.path;
        if (specifier.isImportSpecifier()) {
            let declaration = specifier.parentPath;
            util.removeImport(declaration.node.source.value, name(specifier.node.imported));
        }
    }
}
function precompileTemplate(i) {
    return i.import('@ember/template-compilation', 'precompileTemplate');
}
function name(node) {
    if (node.type === 'StringLiteral') {
        return node.value;
    }
    else {
        return node.name;
    }
}
exports.default = makePlugin((options) => options);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGx1Z2luLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGx1Z2luLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0EseURBQThEO0FBQzlELDJEQUF1RDtBQUN2RCx5Q0FBNEQ7QUFHNUQsaURBQTZDO0FBQzdDLDRDQUFzRTtBQUV0RSxpREFBK0I7QUFZL0IsTUFBTSx5QkFBeUIsR0FBbUI7SUFDaEQ7UUFDRSxVQUFVLEVBQUUsb0JBQW9CO1FBQ2hDLE1BQU0sRUFBRSxLQUFLO1FBQ2Isb0JBQW9CLEVBQUUsSUFBSTtLQUMzQjtJQUNEO1FBQ0UsVUFBVSxFQUFFLHNDQUFzQztRQUNsRCxNQUFNLEVBQUUsU0FBUztRQUNqQixvQkFBb0IsRUFBRSxJQUFJO0tBQzNCO0lBQ0Q7UUFDRSxVQUFVLEVBQUUsNEJBQTRCO1FBQ3hDLE1BQU0sRUFBRSxTQUFTO1FBQ2pCLG9CQUFvQixFQUFFLElBQUk7S0FDM0I7SUFDRDtRQUNFLFVBQVUsRUFBRSw2QkFBNkI7UUFDekMsTUFBTSxFQUFFLG9CQUFvQjtRQUM1QixXQUFXLEVBQUUsSUFBSTtLQUNsQjtJQUNEO1FBQ0UsVUFBVSxFQUFFLDBCQUEwQjtRQUN0QyxNQUFNLEVBQUUsVUFBVTtRQUNsQixXQUFXLEVBQUUsSUFBSTtRQUNqQixhQUFhLEVBQUUsWUFBWTtLQUM1QjtDQUNGLENBQUM7QUErREYsU0FBUyxhQUFhLENBQUMsT0FBZ0I7O0lBQ3JDLElBQUksQ0FBQyxNQUFBLE9BQU8sQ0FBQyxZQUFZLG1DQUFJLE1BQU0sQ0FBQyxLQUFLLE1BQU0sRUFBRTtRQUMvQyxJQUFJLEVBQUUsUUFBUSxFQUFFLEdBQUcsT0FBTyxDQUFDO1FBQzNCLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDYixNQUFNLElBQUksS0FBSyxDQUNiLDZFQUE2RSxDQUM5RSxDQUFDO1NBQ0g7UUFDRCxxQ0FDRSxxQkFBcUIsRUFBRSxFQUFFLEVBQ3pCLG1CQUFtQixFQUFFLEVBQUUsRUFDdkIsVUFBVSxF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QUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IE5vZGVQYXRoIH0gZnJvbSAnQGJhYmVsL3RyYXZlcnNlJztcbmltcG9ydCB0eXBlICogYXMgQmFiZWwgZnJvbSAnQGJhYmVsL2NvcmUnO1xuaW1wb3J0IHR5cGUgeyB0eXBlcyBhcyB0IH0gZnJvbSAnQGJhYmVsL2NvcmUnO1xuaW1wb3J0IHsgSW1wb3J0VXRpbCwgdHlwZSBJbXBvcnRlciB9IGZyb20gJ2JhYmVsLWltcG9ydC11dGlsJztcbmltcG9ydCB7IEV4cHJlc3Npb25QYXJzZXIgfSBmcm9tICcuL2V4cHJlc3Npb24tcGFyc2VyJztcbmltcG9ydCB7IEpTVXRpbHMsIEV4dGVuZGVkUGx1Z2luQnVpbGRlciB9IGZyb20gJy4vanMtdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBFbWJlclRlbXBsYXRlQ29tcGlsZXIsIFByZXByb2Nlc3NPcHRpb25zIH0gZnJvbSAnLi9lbWJlci10ZW1wbGF0ZS1jb21waWxlcic7XG5pbXBvcnQgeyBMZWdhY3lNb2R1bGVOYW1lIH0gZnJvbSAnLi9wdWJsaWMtdHlwZXMnO1xuaW1wb3J0IHsgU2NvcGVMb2NhbHMgfSBmcm9tICcuL3Njb3BlLWxvY2Fscyc7XG5pbXBvcnQgeyBBU1RQbHVnaW5CdWlsZGVyLCBwcmVwcm9jZXNzLCBwcmludCB9IGZyb20gJ0BnbGltbWVyL3N5bnRheCc7XG5cbmV4cG9ydCAqIGZyb20gJy4vcHVibGljLXR5cGVzJztcblxudHlwZSBNb2R1bGVOYW1lID0gTGVnYWN5TW9kdWxlTmFtZSB8ICdAZW1iZXIvdGVtcGxhdGUtY29tcGlsYXRpb24nIHwgJ0BlbWJlci90ZW1wbGF0ZS1jb21waWxlcic7XG5cbmludGVyZmFjZSBNb2R1bGVDb25maWcge1xuICBtb2R1bGVOYW1lOiBNb2R1bGVOYW1lO1xuICBleHBvcnQ6IHN0cmluZztcbiAgYWxsb3dUZW1wbGF0ZUxpdGVyYWw/OiB0cnVlO1xuICBlbmFibGVTY29wZT86IHRydWU7XG4gIHJmYzkzMVN1cHBvcnQ/OiAncG9seWZpbGxlZCc7XG59XG5cbmNvbnN0IElOTElORV9QUkVDT01QSUxFX01PRFVMRVM6IE1vZHVsZUNvbmZpZ1tdID0gW1xuICB7XG4gICAgbW9kdWxlTmFtZTogJ2VtYmVyLWNsaS1odG1sYmFycycsXG4gICAgZXhwb3J0OiAnaGJzJyxcbiAgICBhbGxvd1RlbXBsYXRlTGl0ZXJhbDogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIG1vZHVsZU5hbWU6ICdlbWJlci1jbGktaHRtbGJhcnMtaW5saW5lLXByZWNvbXBpbGUnLFxuICAgIGV4cG9ydDogJ2RlZmF1bHQnLFxuICAgIGFsbG93VGVtcGxhdGVMaXRlcmFsOiB0cnVlLFxuICB9LFxuICB7XG4gICAgbW9kdWxlTmFtZTogJ2h0bWxiYXJzLWlubGluZS1wcmVjb21waWxlJyxcbiAgICBleHBvcnQ6ICdkZWZhdWx0JyxcbiAgICBhbGxvd1RlbXBsYXRlTGl0ZXJhbDogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIG1vZHVsZU5hbWU6ICdAZW1iZXIvdGVtcGxhdGUtY29tcGlsYXRpb24nLFxuICAgIGV4cG9ydDogJ3ByZWNvbXBpbGVUZW1wbGF0ZScsXG4gICAgZW5hYmxlU2NvcGU6IHRydWUsXG4gIH0sXG4gIHtcbiAgICBtb2R1bGVOYW1lOiAnQGVtYmVyL3RlbXBsYXRlLWNvbXBpbGVyJyxcbiAgICBleHBvcnQ6ICd0ZW1wbGF0ZScsXG4gICAgZW5hYmxlU2NvcGU6IHRydWUsXG4gICAgcmZjOTMxU3VwcG9ydDogJ3BvbHlmaWxsZWQnLFxuICB9LFxuXTtcblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zIHtcbiAgLy8gVGhlIGVtYmVyLXRlbXBsYXRlLWNvbXBpbGVyLmpzIG1vZHVsZSB0aGF0IHNoaXBzIHdpdGhpbiB5b3VyIGVtYmVyLXNvdXJjZVxuICAvLyB2ZXJzaW9uLiBNYW5kYXRvcnkgd2hlbiB1c2luZyB0YXJnZXRGb3JtYXQ6ICd3aXJlJy5cbiAgY29tcGlsZXI/OiBFbWJlclRlbXBsYXRlQ29tcGlsZXI7XG5cbiAgLy8gQWxsb3dzIHlvdSB0byByZW1hcCB3aGF0IGltcG9ydHMgd2lsbCBiZSBlbWl0dGVkIGluIG91ciBjb21waWxlZCBvdXRwdXQuIEJ5XG4gIC8vIGV4YW1wbGU6XG4gIC8vXG4gIC8vICAgb3V0cHV0TW9kdWxlT3ZlcnJpZGVzOiB7XG4gIC8vICAgICAnQGVtYmVyL3RlbXBsYXRlLWZhY3RvcnknOiB7XG4gIC8vICAgICAgIGNyZWF0ZVRlbXBsYXRlRmFjdG9yeTogWydjcmVhdGVUZW1wbGF0ZUZhY3RvcnknLCAnQGdsaW1tZXIvY29yZSddLFxuICAvLyAgICAgfVxuICAvLyAgIH1cbiAgLy9cbiAgLy8gTm9ybWFsIEVtYmVyIGFwcHMgc2hvdWxkbid0IG5lZWQgdGhpcywgaXQgZXhpc3RzIHRvIHN1cHBvcnQgb3RoZXJcbiAgLy8gZW52aXJvbm1lbnRzIGxpa2Ugc3RhbmRhbG9uZSBHbGltbWVySlNcbiAgb3V0cHV0TW9kdWxlT3ZlcnJpZGVzPzogUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgW3N0cmluZywgc3RyaW5nXT4+O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIHRoaXMgcGx1Z2luIGltcGxlbWVudHMgb25seSBFbWJlcidzIHN0YWJsZSBwdWJsaWMgQVBJIGZvclxuICAvLyB0ZW1wbGF0ZSBjb21waWxhdGlvbiwgd2hpY2ggaXM6XG4gIC8vXG4gIC8vICAgIGltcG9ydCB7IHByZWNvbXBpbGVUZW1wbGF0ZSB9IGZyb20gJ0BlbWJlci90ZW1wbGF0ZS1jb21waWxhdGlvbic7XG4gIC8vXG4gIC8vIEJ1dCBoaXN0b3JpY2FsbHkgdGhlcmUgYXJlIHNldmVyYWwgb3RoZXIgaW1wb3J0YWJsZSBzeW50YXhlcyBpbiB3aWRlc3ByZWFkXG4gIC8vIHVzZSwgYW5kIHdlIGNhbiBlbmFibGUgdGhvc2UgdG9vIGJ5IGluY2x1ZGluZyB0aGVpciBtb2R1bGUgbmFtZXMgaW4gdGhpc1xuICAvLyBsaXN0LlxuICBlbmFibGVMZWdhY3lNb2R1bGVzPzogTGVnYWN5TW9kdWxlTmFtZVtdO1xuXG4gIC8vIENvbnRyb2xzIHRoZSBvdXRwdXQgZm9ybWF0LlxuICAvL1xuICAvLyAgXCJ3aXJlXCI6IFRoZSBkZWZhdWx0LiBJbiB0aGUgb3V0cHV0LCB5b3VyIHRlbXBsYXRlcyBhcmUgcmVhZHkgdG8gZXhlY3V0ZSBpblxuICAvLyAgdGhlIG1vc3QgcGVyZm9ybWFudCB3YXkuXG4gIC8vXG4gIC8vICBcImhic1wiOiBJbiB0aGUgb3V0cHV0LCB5b3VyIHRlbXBsYXRlcyB3aWxsIHN0aWxsIGJlIGluIEhCUyBmb3JtYXQuXG4gIC8vICBHZW5lcmFsbHkgdGhpcyBtZWFucyB0aGV5IHdpbGwgc3RpbGwgbmVlZCBmdXJ0aGVyIHByb2Nlc3NpbmcgYmVmb3JlXG4gIC8vICB0aGV5J3JlIHJlYWR5IHRvIGV4ZWN1dGUuIFRoZSBwdXJwb3NlIG9mIHRoaXMgbW9kZSBpcyB0byBzdXBwb3J0IHRoaW5nc1xuICAvLyAgbGlrZSBjb2RlbW9kcyBhbmQgcHJlLXB1YmxpY2F0aW9uIHRyYW5zZm9ybWF0aW9ucyBpbiBsaWJyYXJpZXMuXG4gIHRhcmdldEZvcm1hdD86ICd3aXJlJyB8ICdoYnMnO1xuXG4gIC8vIE9wdGlvbmFsIGxpc3Qgb2YgY3VzdG9tIHRyYW5zZm9ybXMgdG8gYXBwbHkgdG8gdGhlIGhhbmRsZWJhcnMgQVNUIGJlZm9yZVxuICAvLyBjb21waWxhdGlvbi5cbiAgdHJhbnNmb3Jtcz86IEV4dGVuZGVkUGx1Z2luQnVpbGRlcltdO1xufVxuXG5pbnRlcmZhY2UgV2lyZU9wdHMge1xuICB0YXJnZXRGb3JtYXQ6ICd3aXJlJztcbiAgY29tcGlsZXI6IEVtYmVyVGVtcGxhdGVDb21waWxlcjtcbiAgb3V0cHV0TW9kdWxlT3ZlcnJpZGVzOiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBbc3RyaW5nLCBzdHJpbmddPj47XG4gIGVuYWJsZUxlZ2FjeU1vZHVsZXM6IExlZ2FjeU1vZHVsZU5hbWVbXTtcbiAgdHJhbnNmb3JtczogRXh0ZW5kZWRQbHVnaW5CdWlsZGVyW107XG59XG5cbmludGVyZmFjZSBIYnNPcHRzIHtcbiAgdGFyZ2V0Rm9ybWF0OiAnaGJzJztcbiAgb3V0cHV0TW9kdWxlT3ZlcnJpZGVzOiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBbc3RyaW5nLCBzdHJpbmddPj47XG4gIGVuYWJsZUxlZ2FjeU1vZHVsZXM6IExlZ2FjeU1vZHVsZU5hbWVbXTtcbiAgdHJhbnNmb3JtczogRXh0ZW5kZWRQbHVnaW5CdWlsZGVyW107XG59XG5cbnR5cGUgTm9ybWFsaXplZE9wdHMgPSBXaXJlT3B0cyB8IEhic09wdHM7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9wdHMob3B0aW9uczogT3B0aW9ucyk6IE5vcm1hbGl6ZWRPcHRzIHtcbiAgaWYgKChvcHRpb25zLnRhcmdldEZvcm1hdCA/PyAnd2lyZScpID09PSAnd2lyZScpIHtcbiAgICBsZXQgeyBjb21waWxlciB9ID0gb3B0aW9ucztcbiAgICBpZiAoIWNvbXBpbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGB3aGVuIHRhcmdldEZvcm1hdD09PVwid2lyZVwiIHlvdSBtdXN0IHNldCB0aGUgY29tcGlsZXIgb3IgY29tcGlsZXJQYXRoIG9wdGlvbmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBvdXRwdXRNb2R1bGVPdmVycmlkZXM6IHt9LFxuICAgICAgZW5hYmxlTGVnYWN5TW9kdWxlczogW10sXG4gICAgICB0cmFuc2Zvcm1zOiBbXSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB0YXJnZXRGb3JtYXQ6ICd3aXJlJyxcbiAgICAgIGNvbXBpbGVyLFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dHB1dE1vZHVsZU92ZXJyaWRlczoge30sXG4gICAgICBlbmFibGVMZWdhY3lNb2R1bGVzOiBbXSxcbiAgICAgIHRyYW5zZm9ybXM6IFtdLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHRhcmdldEZvcm1hdDogJ2hicycsXG4gICAgfTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPiB7XG4gIG9wdHM6IEVudlNwZWNpZmljT3B0aW9ucztcbiAgbm9ybWFsaXplZE9wdHM6IE5vcm1hbGl6ZWRPcHRzO1xuICB1dGlsOiBJbXBvcnRVdGlsO1xuICB0ZW1wbGF0ZUZhY3Rvcnk6IHsgbW9kdWxlTmFtZTogc3RyaW5nOyBleHBvcnROYW1lOiBzdHJpbmcgfTtcbiAgcHJvZ3JhbTogTm9kZVBhdGg8dC5Qcm9ncmFtPjtcbiAgbGFzdEluc2VydGVkUGF0aDogTm9kZVBhdGg8dC5TdGF0ZW1lbnQ+IHwgdW5kZWZpbmVkO1xuICBmaWxlbmFtZTogc3RyaW5nO1xuICByZWN1cnNpb25HdWFyZDogU2V0PHVua25vd24+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZVBsdWdpbjxFbnZTcGVjaWZpY09wdGlvbnM+KGxvYWRPcHRpb25zOiAob3B0czogRW52U3BlY2lmaWNPcHRpb25zKSA9PiBPcHRpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBodG1sYmFyc0lubGluZVByZWNvbXBpbGUoXG4gICAgYmFiZWw6IHR5cGVvZiBCYWJlbFxuICApOiBCYWJlbC5QbHVnaW5PYmo8U3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPj4ge1xuICAgIGxldCB0ID0gYmFiZWwudHlwZXM7XG5cbiAgICBjb25zdCBwbHVnaW4gPSB7XG4gICAgICB2aXNpdG9yOiB7XG4gICAgICAgIFByb2dyYW06IHtcbiAgICAgICAgICBlbnRlcihwYXRoOiBOb2RlUGF0aDx0LlByb2dyYW0+LCBzdGF0ZTogU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPikge1xuICAgICAgICAgICAgc3RhdGUubm9ybWFsaXplZE9wdHMgPSBub3JtYWxpemVPcHRzKGxvYWRPcHRpb25zKHN0YXRlLm9wdHMpKTtcbiAgICAgICAgICAgIHN0YXRlLnRlbXBsYXRlRmFjdG9yeSA9IHRlbXBsYXRlRmFjdG9yeUNvbmZpZyhzdGF0ZS5ub3JtYWxpemVkT3B0cyk7XG4gICAgICAgICAgICBzdGF0ZS51dGlsID0gbmV3IEltcG9ydFV0aWwoYmFiZWwsIHBhdGgpO1xuICAgICAgICAgICAgc3RhdGUucHJvZ3JhbSA9IHBhdGg7XG4gICAgICAgICAgICBzdGF0ZS5yZWN1cnNpb25HdWFyZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGV4aXQoX3BhdGg6IE5vZGVQYXRoPHQuUHJvZ3JhbT4sIHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+KSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUubm9ybWFsaXplZE9wdHMudGFyZ2V0Rm9ybWF0ID09PSAnd2lyZScpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgeyBtb2R1bGVOYW1lLCBleHBvcnQ6IGV4cG9ydE5hbWUgfSBvZiBjb25maWd1cmVkTW9kdWxlcyhzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS51dGlsLnJlbW92ZUltcG9ydChtb2R1bGVOYW1lLCBleHBvcnROYW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG5cbiAgICAgICAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKFxuICAgICAgICAgIHBhdGg6IE5vZGVQYXRoPHQuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uPixcbiAgICAgICAgICBzdGF0ZTogU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPlxuICAgICAgICApIHtcbiAgICAgICAgICBsZXQgdGFnUGF0aCA9IHBhdGguZ2V0KCd0YWcnKTtcblxuICAgICAgICAgIGlmICghdGFnUGF0aC5pc0lkZW50aWZpZXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgY29uZmlnID0gcmVmZXJlbmNlc0lubGluZUNvbXBpbGVyKHRhZ1BhdGgsIHN0YXRlKTtcbiAgICAgICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghY29uZmlnLmFsbG93VGVtcGxhdGVMaXRlcmFsKSB7XG4gICAgICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgICAgIGBBdHRlbXB0ZWQgdG8gdXNlIFxcYCR7dGFnUGF0aC5ub2RlLm5hbWV9XFxgIGFzIGEgdGVtcGxhdGUgdGFnLCBidXQgaXQgY2FuIG9ubHkgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24gd2l0aCBhIHN0cmluZyBwYXNzZWQgdG8gaXQ6ICR7dGFnUGF0aC5ub2RlLm5hbWV9KCdjb250ZW50IGhlcmUnKWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhdGgubm9kZS5xdWFzaS5leHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICAgICAgJ3BsYWNlaG9sZGVycyBpbnNpZGUgYSB0YWdnZWQgdGVtcGxhdGUgc3RyaW5nIGFyZSBub3Qgc3VwcG9ydGVkJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgdGVtcGxhdGUgPSBwYXRoLm5vZGUucXVhc2kucXVhc2lzLm1hcCgocXVhc2kpID0+IHF1YXNpLnZhbHVlLmNvb2tlZCkuam9pbignJyk7XG4gICAgICAgICAgaWYgKHN0YXRlLm5vcm1hbGl6ZWRPcHRzLnRhcmdldEZvcm1hdCA9PT0gJ3dpcmUnKSB7XG4gICAgICAgICAgICBpbnNlcnRDb21waWxlZFRlbXBsYXRlKFxuICAgICAgICAgICAgICBiYWJlbCxcbiAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgIHN0YXRlLm5vcm1hbGl6ZWRPcHRzLFxuICAgICAgICAgICAgICB0ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgdW5kZWZpbmVkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnNlcnRUcmFuc2Zvcm1lZFRlbXBsYXRlKGJhYmVsLCBzdGF0ZSwgdGVtcGxhdGUsIHBhdGgsIHt9LCBjb25maWcsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIENhbGxFeHByZXNzaW9uKHBhdGg6IE5vZGVQYXRoPHQuQ2FsbEV4cHJlc3Npb24+LCBzdGF0ZTogU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPikge1xuICAgICAgICAgIGxldCBjYWxsZWVQYXRoID0gcGF0aC5nZXQoJ2NhbGxlZScpO1xuXG4gICAgICAgICAgaWYgKCFjYWxsZWVQYXRoLmlzSWRlbnRpZmllcigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBjb25maWcgPSByZWZlcmVuY2VzSW5saW5lQ29tcGlsZXIoY2FsbGVlUGF0aCwgc3RhdGUpO1xuICAgICAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXRlLnJlY3Vyc2lvbkd1YXJkLmhhcyhwYXRoLm5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhdGguZ2V0KCdhcmd1bWVudHMnKS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgICAgIGAke2NhbGxlZVBhdGgubm9kZS5uYW1lfSBjYW4gb25seSBiZSBpbnZva2VkIHdpdGggMiBhcmd1bWVudHM6IHRoZSB0ZW1wbGF0ZSBzdHJpbmcgYW5kIGFueSBzdGF0aWMgb3B0aW9uc2BcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IFtmaXJzdEFyZywgc2Vjb25kQXJnXSA9IHBhdGguZ2V0KCdhcmd1bWVudHMnKTtcblxuICAgICAgICAgIGxldCB0ZW1wbGF0ZTtcblxuICAgICAgICAgIHN3aXRjaCAoZmlyc3RBcmc/Lm5vZGUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnU3RyaW5nTGl0ZXJhbCc6XG4gICAgICAgICAgICAgIHRlbXBsYXRlID0gZmlyc3RBcmcubm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdUZW1wbGF0ZUxpdGVyYWwnOlxuICAgICAgICAgICAgICBpZiAoZmlyc3RBcmcubm9kZS5leHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgICAgICAgICAncGxhY2Vob2xkZXJzIGluc2lkZSBhIHRlbXBsYXRlIHN0cmluZyBhcmUgbm90IHN1cHBvcnRlZCdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gZmlyc3RBcmcubm9kZS5xdWFzaXMubWFwKChxdWFzaSkgPT4gcXVhc2kudmFsdWUuY29va2VkKS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1RhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbic6XG4gICAgICAgICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICAgICAgICBgdGFnZ2VkIHRlbXBsYXRlIHN0cmluZ3MgaW5zaWRlICR7Y2FsbGVlUGF0aC5ub2RlLm5hbWV9IGFyZSBub3Qgc3VwcG9ydGVkYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgICAgICAgIGAke2NhbGxlZVBhdGgubm9kZS5uYW1lfSBzaG91bGQgYmUgaW52b2tlZCB3aXRoIGF0IGxlYXN0IGEgc2luZ2xlIGFyZ3VtZW50ICh0aGUgdGVtcGxhdGUgc3RyaW5nKWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgdXNlclR5cGVkT3B0aW9uczogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgICAgICAgbGV0IGJhY2tpbmdDbGFzczogdW5kZWZpbmVkIHwgTm9kZVBhdGg8UGFyYW1ldGVyczx0eXBlb2YgdC5jYWxsRXhwcmVzc2lvbj5bMV1bbnVtYmVyXT47XG5cbiAgICAgICAgICBpZiAoIXNlY29uZEFyZykge1xuICAgICAgICAgICAgdXNlclR5cGVkT3B0aW9ucyA9IHt9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXNlY29uZEFyZy5pc09iamVjdEV4cHJlc3Npb24oKSkge1xuICAgICAgICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgICAgICAgYCR7Y2FsbGVlUGF0aC5ub2RlLm5hbWV9IGNhbiBvbmx5IGJlIGludm9rZWQgd2l0aCAyIGFyZ3VtZW50czogdGhlIHRlbXBsYXRlIHN0cmluZywgYW5kIGFueSBzdGF0aWMgb3B0aW9uc2BcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXNlclR5cGVkT3B0aW9ucyA9IG5ldyBFeHByZXNzaW9uUGFyc2VyKGJhYmVsKS5wYXJzZU9iamVjdEV4cHJlc3Npb24oXG4gICAgICAgICAgICAgIGNhbGxlZVBhdGgubm9kZS5uYW1lLFxuICAgICAgICAgICAgICBzZWNvbmRBcmcsXG4gICAgICAgICAgICAgIGNvbmZpZy5lbmFibGVTY29wZSxcbiAgICAgICAgICAgICAgQm9vbGVhbihjb25maWcucmZjOTMxU3VwcG9ydClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLnJmYzkzMVN1cHBvcnQgJiYgdXNlclR5cGVkT3B0aW9ucy5jb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgYmFja2luZ0NsYXNzID0gdXNlclR5cGVkT3B0aW9ucy5jb21wb25lbnQgYXMgTm9kZVBhdGg8XG4gICAgICAgICAgICAgICAgUGFyYW1ldGVyczx0eXBlb2YgdC5jYWxsRXhwcmVzc2lvbj5bMV1bbnVtYmVyXVxuICAgICAgICAgICAgICA+O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGF0ZS5ub3JtYWxpemVkT3B0cy50YXJnZXRGb3JtYXQgPT09ICd3aXJlJykge1xuICAgICAgICAgICAgaW5zZXJ0Q29tcGlsZWRUZW1wbGF0ZShcbiAgICAgICAgICAgICAgYmFiZWwsXG4gICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICBzdGF0ZS5ub3JtYWxpemVkT3B0cyxcbiAgICAgICAgICAgICAgdGVtcGxhdGUsXG4gICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgIHVzZXJUeXBlZE9wdGlvbnMsXG4gICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgYmFja2luZ0NsYXNzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnNlcnRUcmFuc2Zvcm1lZFRlbXBsYXRlKFxuICAgICAgICAgICAgICBiYWJlbCxcbiAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgIHRlbXBsYXRlLFxuICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICB1c2VyVHlwZWRPcHRpb25zLFxuICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgIGJhY2tpbmdDbGFzc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgcHJlKHRoaXM6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4sIGZpbGUpIHtcbiAgICAgICAgLy8gcnVuIG91ciBwcm9jZXNzaW5nIGluIHByZSBzbyB0aGF0IGltcG9ydHMgZm9yIGd0c1xuICAgICAgICAvLyBhcmUga2VwdCBmb3Igb3RoZXIgcGx1Z2lucy5cbiAgICAgICAgYmFiZWwudHJhdmVyc2UoZmlsZS5hc3QsIHBsdWdpbi52aXNpdG9yLCBmaWxlLnNjb3BlLCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdG9yOiB7fSxcbiAgICB9O1xuICB9IGFzIChiYWJlbDogdHlwZW9mIEJhYmVsKSA9PiBCYWJlbC5QbHVnaW5PYmo8dW5rbm93bj47XG59XG5cbmZ1bmN0aW9uKiBjb25maWd1cmVkTW9kdWxlczxFbnZTcGVjaWZpY09wdGlvbnM+KHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+KSB7XG4gIGZvciAobGV0IG1vZHVsZUNvbmZpZyBvZiBJTkxJTkVfUFJFQ09NUElMRV9NT0RVTEVTKSB7XG4gICAgaWYgKFxuICAgICAgbW9kdWxlQ29uZmlnLm1vZHVsZU5hbWUgIT09ICdAZW1iZXIvdGVtcGxhdGUtY29tcGlsYXRpb24nICYmXG4gICAgICBtb2R1bGVDb25maWcubW9kdWxlTmFtZSAhPT0gJ0BlbWJlci90ZW1wbGF0ZS1jb21waWxlcicgJiZcbiAgICAgICFzdGF0ZS5ub3JtYWxpemVkT3B0cy5lbmFibGVMZWdhY3lNb2R1bGVzLmluY2x1ZGVzKG1vZHVsZUNvbmZpZy5tb2R1bGVOYW1lKVxuICAgICkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHlpZWxkIG1vZHVsZUNvbmZpZztcbiAgfVxufVxuXG5mdW5jdGlvbiByZWZlcmVuY2VzSW5saW5lQ29tcGlsZXI8RW52U3BlY2lmaWNPcHRpb25zPihcbiAgcGF0aDogTm9kZVBhdGg8dC5JZGVudGlmaWVyPixcbiAgc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz5cbik6IE1vZHVsZUNvbmZpZyB8IHVuZGVmaW5lZCB7XG4gIGZvciAobGV0IG1vZHVsZUNvbmZpZyBvZiBjb25maWd1cmVkTW9kdWxlcyhzdGF0ZSkpIHtcbiAgICBpZiAocGF0aC5yZWZlcmVuY2VzSW1wb3J0KG1vZHVsZUNvbmZpZy5tb2R1bGVOYW1lLCBtb2R1bGVDb25maWcuZXhwb3J0KSkge1xuICAgICAgcmV0dXJuIG1vZHVsZUNvbmZpZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gcnVudGltZUVycm9ySUlGRShiYWJlbDogdHlwZW9mIEJhYmVsLCByZXBsYWNlbWVudHM6IHsgRVJST1JfTUVTU0FHRTogc3RyaW5nIH0pIHtcbiAgbGV0IHN0YXRlbWVudCA9IGJhYmVsLnRlbXBsYXRlKGAoZnVuY3Rpb24oKSB7XFxuICB0aHJvdyBuZXcgRXJyb3IoJ0VSUk9SX01FU1NBR0UnKTtcXG59KSgpO2ApKFxuICAgIHJlcGxhY2VtZW50c1xuICApIGFzIHQuRXhwcmVzc2lvblN0YXRlbWVudDtcbiAgcmV0dXJuIHN0YXRlbWVudC5leHByZXNzaW9uO1xufVxuXG5mdW5jdGlvbiBidWlsZFNjb3BlTG9jYWxzKFxuICB1c2VyVHlwZWRPcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgZm9ybWF0T3B0aW9uczogTW9kdWxlQ29uZmlnLFxuICB0YXJnZXQ6IE5vZGVQYXRoPHQuRXhwcmVzc2lvbj5cbik6IFNjb3BlTG9jYWxzIHtcbiAgaWYgKGZvcm1hdE9wdGlvbnMucmZjOTMxU3VwcG9ydCAmJiB1c2VyVHlwZWRPcHRpb25zLmV2YWwpIHtcbiAgICByZXR1cm4gbmV3IFNjb3BlTG9jYWxzKHsgbW9kZTogJ2ltcGxpY2l0JywganNQYXRoOiB0YXJnZXQgfSk7XG4gIH0gZWxzZSBpZiAodXNlclR5cGVkT3B0aW9ucy5zY29wZSkge1xuICAgIHJldHVybiB1c2VyVHlwZWRPcHRpb25zLnNjb3BlIGFzIFNjb3BlTG9jYWxzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgU2NvcGVMb2NhbHMoeyBtb2RlOiAnZXhwbGljaXQnIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUHJlY29tcGlsZU9wdGlvbnM8RW52U3BlY2lmaWNPcHRpb25zPihcbiAgYmFiZWw6IHR5cGVvZiBCYWJlbCxcbiAgdGFyZ2V0OiBOb2RlUGF0aDx0LkV4cHJlc3Npb24+LFxuICBzdGF0ZTogU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPixcbiAgdGVtcGxhdGU6IHN0cmluZyxcbiAgdXNlclR5cGVkT3B0aW9uczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIGNvbmZpZzogTW9kdWxlQ29uZmlnLFxuICBzY29wZTogU2NvcGVMb2NhbHNcbik6IFByZXByb2Nlc3NPcHRpb25zICYgUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xuICBsZXQganN1dGlscyA9IG5ldyBKU1V0aWxzKGJhYmVsLCBzdGF0ZSwgdGFyZ2V0LCBzY29wZS5hZGQuYmluZChzY29wZSksIHN0YXRlLnV0aWwpO1xuICBsZXQgbWV0YSA9IE9iamVjdC5hc3NpZ24oeyBqc3V0aWxzIH0sIHVzZXJUeXBlZE9wdGlvbnM/Lm1ldGEpO1xuXG4gIGxldCBvdXRwdXQ6IFByZXByb2Nlc3NPcHRpb25zICYgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7XG4gICAgY29udGVudHM6IHRlbXBsYXRlLFxuXG4gICAgLy8gd2UndmUgZXh0ZW5kZWQgbWV0YSB0byBhZGQganN1dGlscywgYnV0IHRoZSB0eXBlcyBpbiBAZ2xpbW1lci9zeW50YXhcbiAgICAvLyBkb24ndCBhY2NvdW50IGZvciBleHRlbnNpb25cbiAgICBtZXRhOiBtZXRhIGFzIFByZXByb2Nlc3NPcHRpb25zWydtZXRhJ10sXG5cbiAgICAvLyBUT0RPOiBlbWJyb2lkZXIncyB0ZW1wbGF0ZS1jb21waWxlciBhbGxvd3MgdGhpcyB0byBiZSBvdmVycmlkZW4gdG8gZ2V0XG4gICAgLy8gYmFja3dhcmQtY29tcGF0aWJsZSBtb2R1bGUgbmFtZXMgdGhhdCBkb24ndCBtYXRjaCB0aGUgcmVhbCBuYW1lIG9mIHRoZVxuICAgIC8vIG9uLWRpc2sgZmlsZS4gV2hhdCdzIG91ciBwbGFuIGZvciBtaWdyYXRpbmcgcGVvcGxlIGF3YXkgZnJvbSB0aGF0P1xuICAgIG1vZHVsZU5hbWU6IHN0YXRlLmZpbGVuYW1lLFxuXG4gICAgLy8gVGhpcyBpcyBoZXJlIHNvIGl0J3MgKmFsd2F5cyogdGhlIHJlYWwgZmlsZW5hbWUuIEhpc3RvcmljYWxseSwgdGhlcmUgaXNcbiAgICAvLyBhbHNvIGBtb2R1bGVOYW1lYCBidXQgdGhhdCBkaWQgbm90IG1hdGNoIHRoZSByZWFsIG9uLWRpc2sgZmlsZW5hbWUsIGl0XG4gICAgLy8gd2FzIHRoZSBub3Rpb25hbCBydW50aW1lIG1vZHVsZSBuYW1lIGZyb20gY2xhc3NpYyBlbWJlciBidWlsZHMuXG4gICAgZmlsZW5hbWU6IHN0YXRlLmZpbGVuYW1lLFxuXG4gICAgcGx1Z2luczoge1xuICAgICAgLy8gdGhlIGNhc3QgaXMgbmVlZGVkIGhlcmUgb25seSBiZWNhdXNlIG91ciBtZXRhIGlzIGV4dGVuZGVkLiBUaGF0IGlzLFxuICAgICAgLy8gdGhlc2UgcGx1Z2lucyBjYW4gYWNjZXNzIG1ldGEuanN1dGlscy5cbiAgICAgIGFzdDogWy4uLnN0YXRlLm5vcm1hbGl6ZWRPcHRzLnRyYW5zZm9ybXMsIHNjb3BlLmNyYXdsKCldIGFzIEFTVFBsdWdpbkJ1aWxkZXJbXSxcbiAgICB9LFxuICB9O1xuXG4gIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh1c2VyVHlwZWRPcHRpb25zKSkge1xuICAgIGlmIChrZXkgIT09ICdzY29wZScpIHtcbiAgICAgIC8vIGBzY29wZWAgaW4gdGhlIHVzZXItZmFjaW5nIEFQSSBiZWNvbWVzIGBsb2NhbHNgIGluIHRoZSBsb3ctbGV2ZWxcbiAgICAgIC8vIGVtYmVyLXRlbXBsYXRlLWNvbXBpbGVyIEFQSVxuICAgICAgb3V0cHV0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBvdXRwdXQubG9jYWxzID0gc2NvcGUubG9jYWxzO1xuXG4gIGlmIChjb25maWcucmZjOTMxU3VwcG9ydCkge1xuICAgIG91dHB1dC5zdHJpY3RNb2RlID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIHJlbWFwQW5kQmluZElkZW50aWZpZXJzKHRhcmdldDogTm9kZVBhdGgsIGJhYmVsOiB0eXBlb2YgQmFiZWwsIHNjb3BlTG9jYWxzOiBTY29wZUxvY2Fscykge1xuICB0YXJnZXQudHJhdmVyc2Uoe1xuICAgIElkZW50aWZpZXIocGF0aDogTm9kZVBhdGg8dC5JZGVudGlmaWVyPikge1xuICAgICAgaWYgKHNjb3BlTG9jYWxzLmhhcyhwYXRoLm5vZGUubmFtZSkgJiYgcGF0aC5ub2RlLm5hbWUgIT09IHNjb3BlTG9jYWxzLmdldChwYXRoLm5vZGUubmFtZSkpIHtcbiAgICAgICAgLy8gdGhpcyBpZGVudGlmaWVyIGhhcyBkaWZmZXJlbnQgbmFtZXMgaW4gaGJzIHZzIGpzLCBzbyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHJlcGxhY2UgdGhlIGhicyBuYW1lIGluIHRoZSB0ZW1wbGF0ZSBjb21waWxlciBvdXRwdXQgd2l0aCB0aGUganNcbiAgICAgICAgLy8gbmFtZVxuICAgICAgICBwYXRoLnJlcGxhY2VXaXRoKGJhYmVsLnR5cGVzLmlkZW50aWZpZXIoc2NvcGVMb2NhbHMuZ2V0KHBhdGgubm9kZS5uYW1lKSkpO1xuICAgICAgfVxuICAgICAgLy8gdGhpcyBpcyB3aGVyZSB3ZSB0ZWxsIGJhYmVsJ3Mgc2NvcGUgc3lzdGVtIGFib3V0IHRoZSBuZXcgcmVmZXJlbmNlIHdlXG4gICAgICAvLyBqdXN0IGludHJvZHVjZWQuIEBiYWJlbC9wbHVnaW4tdHJhbnNmb3JtLXR5cGVzY3JpcHQgaW4gcGFydGljdWxhclxuICAgICAgLy8gY2FyZXMgYSBsb3QgYWJvdXQgdGhvc2UgcmVmZXJlbmNlcyBiZWluZyBwcmVzZW50LlxuICAgICAgcGF0aC5zY29wZS5nZXRCaW5kaW5nKHBhdGgubm9kZS5uYW1lKT8ucmVmZXJlbmNlKHBhdGgpO1xuICAgIH0sXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRDb21waWxlZFRlbXBsYXRlPEVudlNwZWNpZmljT3B0aW9ucz4oXG4gIGJhYmVsOiB0eXBlb2YgQmFiZWwsXG4gIHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+LFxuICBvcHRzOiBXaXJlT3B0cyxcbiAgdGVtcGxhdGU6IHN0cmluZyxcbiAgdGFyZ2V0OiBOb2RlUGF0aDx0LkV4cHJlc3Npb24+LFxuICB1c2VyVHlwZWRPcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgY29uZmlnOiBNb2R1bGVDb25maWcsXG4gIGJhY2tpbmdDbGFzczogTm9kZVBhdGg8UGFyYW1ldGVyczx0eXBlb2YgdC5jYWxsRXhwcmVzc2lvbj5bMV1bbnVtYmVyXT4gfCB1bmRlZmluZWRcbikge1xuICBsZXQgdCA9IGJhYmVsLnR5cGVzO1xuICBsZXQgc2NvcGVMb2NhbHMgPSBidWlsZFNjb3BlTG9jYWxzKHVzZXJUeXBlZE9wdGlvbnMsIGNvbmZpZywgdGFyZ2V0KTtcbiAgbGV0IG9wdGlvbnMgPSBidWlsZFByZWNvbXBpbGVPcHRpb25zKFxuICAgIGJhYmVsLFxuICAgIHRhcmdldCxcbiAgICBzdGF0ZSxcbiAgICB0ZW1wbGF0ZSxcbiAgICB1c2VyVHlwZWRPcHRpb25zLFxuICAgIGNvbmZpZyxcbiAgICBzY29wZUxvY2Fsc1xuICApO1xuXG4gIGxldCBwcmVjb21waWxlUmVzdWx0U3RyaW5nOiBzdHJpbmc7XG5cbiAgLy8gaW5zZXJ0UnVudGltZUVycm9ycyBpcyBsZWdhY3kgYW5kIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIG5ld2VyIHJmYzkzMSBmb3JtXG4gIGlmIChvcHRpb25zLmluc2VydFJ1bnRpbWVFcnJvcnMgJiYgIWNvbmZpZy5yZmM5MzFTdXBwb3J0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHByZWNvbXBpbGVSZXN1bHRTdHJpbmcgPSBvcHRzLmNvbXBpbGVyLnByZWNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0YXJnZXQucmVwbGFjZVdpdGgocnVudGltZUVycm9ySUlGRShiYWJlbCwgeyBFUlJPUl9NRVNTQUdFOiAoZXJyb3IgYXMgYW55KS5tZXNzYWdlIH0pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcHJlY29tcGlsZVJlc3VsdFN0cmluZyA9IG9wdHMuY29tcGlsZXIucHJlY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBsZXQgdGVtcGxhdGVFeHByZXNzaW9uID0gYmFiZWwudGVtcGxhdGUuZXhwcmVzc2lvbi5hc3QocHJlY29tcGlsZVJlc3VsdFN0cmluZyk7XG5cbiAgdC5hZGRDb21tZW50KFxuICAgIHRlbXBsYXRlRXhwcmVzc2lvbixcbiAgICAnbGVhZGluZycsXG4gICAgYFxcbiAgJHt0ZW1wbGF0ZS5yZXBsYWNlKC9cXCpcXC8vZywgJypcXFxcLycpfVxcbmAsXG4gICAgLyogbGluZSBjb21tZW50PyAqLyBmYWxzZVxuICApO1xuXG4gIHN0YXRlLnV0aWwucmVwbGFjZVdpdGgodGFyZ2V0LCAoaSkgPT4ge1xuICAgIGxldCB0ZW1wbGF0ZUZhY3RvcnlJZGVudGlmaWVyID0gaS5pbXBvcnQoXG4gICAgICBzdGF0ZS50ZW1wbGF0ZUZhY3RvcnkubW9kdWxlTmFtZSxcbiAgICAgIHN0YXRlLnRlbXBsYXRlRmFjdG9yeS5leHBvcnROYW1lXG4gICAgKTtcblxuICAgIGxldCBleHByZXNzaW9uID0gdC5jYWxsRXhwcmVzc2lvbih0ZW1wbGF0ZUZhY3RvcnlJZGVudGlmaWVyLCBbdGVtcGxhdGVFeHByZXNzaW9uXSk7XG5cbiAgICBpZiAoY29uZmlnLnJmYzkzMVN1cHBvcnQpIHtcbiAgICAgIGV4cHJlc3Npb24gPSB0LmNhbGxFeHByZXNzaW9uKGkuaW1wb3J0KCdAZW1iZXIvY29tcG9uZW50JywgJ3NldENvbXBvbmVudFRlbXBsYXRlJyksIFtcbiAgICAgICAgZXhwcmVzc2lvbixcbiAgICAgICAgYmFja2luZ0NsYXNzPy5ub2RlID8/XG4gICAgICAgICAgdC5jYWxsRXhwcmVzc2lvbihcbiAgICAgICAgICAgIGkuaW1wb3J0KCdAZW1iZXIvY29tcG9uZW50L3RlbXBsYXRlLW9ubHknLCAnZGVmYXVsdCcsICd0ZW1wbGF0ZU9ubHknKSxcbiAgICAgICAgICAgIFtdXG4gICAgICAgICAgKSxcbiAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgfSk7XG5cbiAgcmVtYXBBbmRCaW5kSWRlbnRpZmllcnModGFyZ2V0LCBiYWJlbCwgc2NvcGVMb2NhbHMpO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRUcmFuc2Zvcm1lZFRlbXBsYXRlPEVudlNwZWNpZmljT3B0aW9ucz4oXG4gIGJhYmVsOiB0eXBlb2YgQmFiZWwsXG4gIHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+LFxuICB0ZW1wbGF0ZTogc3RyaW5nLFxuICB0YXJnZXQ6IE5vZGVQYXRoPHQuQ2FsbEV4cHJlc3Npb24+IHwgTm9kZVBhdGg8dC5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24+LFxuICB1c2VyVHlwZWRPcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgZm9ybWF0T3B0aW9uczogTW9kdWxlQ29uZmlnLFxuICBiYWNraW5nQ2xhc3M6IE5vZGVQYXRoPFBhcmFtZXRlcnM8dHlwZW9mIHQuY2FsbEV4cHJlc3Npb24+WzFdW251bWJlcl0+IHwgdW5kZWZpbmVkXG4pIHtcbiAgbGV0IHQgPSBiYWJlbC50eXBlcztcbiAgbGV0IHNjb3BlTG9jYWxzID0gYnVpbGRTY29wZUxvY2Fscyh1c2VyVHlwZWRPcHRpb25zLCBmb3JtYXRPcHRpb25zLCB0YXJnZXQpO1xuICBsZXQgb3B0aW9ucyA9IGJ1aWxkUHJlY29tcGlsZU9wdGlvbnMoXG4gICAgYmFiZWwsXG4gICAgdGFyZ2V0LFxuICAgIHN0YXRlLFxuICAgIHRlbXBsYXRlLFxuICAgIHVzZXJUeXBlZE9wdGlvbnMsXG4gICAgZm9ybWF0T3B0aW9ucyxcbiAgICBzY29wZUxvY2Fsc1xuICApO1xuICBsZXQgYXN0ID0gcHJlcHJvY2Vzcyh0ZW1wbGF0ZSwgeyAuLi5vcHRpb25zLCBtb2RlOiAnY29kZW1vZCcgfSk7XG4gIGxldCB0cmFuc2Zvcm1lZCA9IHByaW50KGFzdCwgeyBlbnRpdHlFbmNvZGluZzogJ3JhdycgfSk7XG5cbiAgaWYgKHRhcmdldC5pc0NhbGxFeHByZXNzaW9uKCkpIHtcbiAgICB1cGRhdGVDYWxsRm9ybTxFbnZTcGVjaWZpY09wdGlvbnM+KFxuICAgICAgdGFyZ2V0LFxuICAgICAgdHJhbnNmb3JtZWQsXG4gICAgICBmb3JtYXRPcHRpb25zLFxuICAgICAgc2NvcGVMb2NhbHMsXG4gICAgICBzdGF0ZSxcbiAgICAgIGJhYmVsLFxuICAgICAgYmFja2luZ0NsYXNzXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVCYWNrdGlja0Zvcm08RW52U3BlY2lmaWNPcHRpb25zPihzY29wZUxvY2Fscywgc3RhdGUsIHRhcmdldCwgdCwgdHJhbnNmb3JtZWQsIGJhYmVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVCYWNrdGlja0Zvcm08RW52U3BlY2lmaWNPcHRpb25zPihcbiAgc2NvcGVMb2NhbHM6IFNjb3BlTG9jYWxzLFxuICBzdGF0ZTogU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPixcbiAgdGFyZ2V0OiBOb2RlUGF0aDx0LlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbj4sXG4gIHQ6IHR5cGVvZiBCYWJlbC50eXBlcyxcbiAgdHJhbnNmb3JtZWQ6IHN0cmluZyxcbiAgYmFiZWw6IHR5cGVvZiBCYWJlbFxuKSB7XG4gIGlmIChzY29wZUxvY2Fscy5pc0VtcHR5KCkpIHtcbiAgICAvLyBzaW1wbGUgY2FzZToganVzdCByZXBsYWNlIHRoZSBzdHJpbmcgbGl0ZXJhbCBwYXJ0IHdpdGggdGhlIHRyYW5zZm9ybWVkXG4gICAgLy8gdGVtcGxhdGUgY29udGVudHNcbiAgICAodGFyZ2V0LmdldCgncXVhc2knKS5nZXQoJ3F1YXNpcy4wJykgYXMgTm9kZVBhdGg8dC5UZW1wbGF0ZUVsZW1lbnQ+KS5yZXBsYWNlV2l0aChcbiAgICAgIHQudGVtcGxhdGVFbGVtZW50KHsgcmF3OiB0cmFuc2Zvcm1lZCB9KVxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gbmVlZCB0byBhZGQgc2NvcGUsIHNvIG5lZWQgdG8gcmVwbGFjZSB0aGUgYmFja3RpY2tzIGZvcm0gd2l0aCBhIGNhbGxcbiAgLy8gZXhwcmVzc2lvbiB0byBwcmVjb21waWxlVGVtcGxhdGVcbiAgbWF5YmVQcnVuZUltcG9ydChzdGF0ZS51dGlsLCB0YXJnZXQuZ2V0KCd0YWcnKSk7XG4gIGxldCBuZXdDYWxsID0gc3RhdGUudXRpbC5yZXBsYWNlV2l0aCh0YXJnZXQsIChpKSA9PlxuICAgIHQuY2FsbEV4cHJlc3Npb24ocHJlY29tcGlsZVRlbXBsYXRlKGkpLCBbdC5zdHJpbmdMaXRlcmFsKHRyYW5zZm9ybWVkKV0pXG4gICk7XG4gIHVwZGF0ZVNjb3BlKGJhYmVsLCBuZXdDYWxsLCBzY29wZUxvY2Fscyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNhbGxGb3JtPEVudlNwZWNpZmljT3B0aW9ucz4oXG4gIHRhcmdldDogTm9kZVBhdGg8QmFiZWwudHlwZXMuQ2FsbEV4cHJlc3Npb24+LFxuICB0cmFuc2Zvcm1lZDogc3RyaW5nLFxuICBmb3JtYXRPcHRpb25zOiBNb2R1bGVDb25maWcsXG4gIHNjb3BlTG9jYWxzOiBTY29wZUxvY2FscyxcbiAgc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4sXG4gIGJhYmVsOiB0eXBlb2YgQmFiZWwsXG4gIGJhY2tpbmdDbGFzczpcbiAgICB8IE5vZGVQYXRoPEJhYmVsLnR5cGVzLkV4cHJlc3Npb24gfCBCYWJlbC50eXBlcy5Bcmd1bWVudFBsYWNlaG9sZGVyIHwgQmFiZWwudHlwZXMuU3ByZWFkRWxlbWVudD5cbiAgICB8IHVuZGVmaW5lZFxuKSB7XG4gIC8vIGZpcnN0IHRoZSBzaW1wbGUgcGFydDogcmVwbGFjaW5nIHRoZSBzdHJpbmcgbGl0ZXJhbCB3aXRoIHRoZSBhY3R1YWwgYm9keSBvZlxuICAvLyB0aGUgcmV3cml0dGVuIHRlbXBsYXRlXG4gICh0YXJnZXQuZ2V0KCdhcmd1bWVudHMuMCcpIGFzIE5vZGVQYXRoPHQuTm9kZT4pLnJlcGxhY2VXaXRoKFxuICAgIGJhYmVsLnR5cGVzLnN0cmluZ0xpdGVyYWwodHJhbnNmb3JtZWQpXG4gICk7XG5cbiAgaWYgKCFmb3JtYXRPcHRpb25zLmVuYWJsZVNjb3BlICYmICFzY29wZUxvY2Fscy5pc0VtcHR5KCkpIHtcbiAgICAvLyBhbiBBU1QgdHJhbnNmb3JtIGFkZGVkIGxleGljYWxseSBzY29wZWQgdmFsdWVzIHRvIGEgdGVtcGxhdGUgdGhhdFxuICAgIC8vIHdhc24ndCBhbHJlYWR5IGluIGEgZm9ybSB0aGF0IHN1cHBvcnRzIHRoZW0sIHNvIGNvbnZlcnQgZm9ybS5cbiAgICBtYXliZVBydW5lSW1wb3J0KHN0YXRlLnV0aWwsIHRhcmdldC5nZXQoJ2NhbGxlZScpKTtcbiAgICBzdGF0ZS51dGlsLnJlcGxhY2VXaXRoKHRhcmdldC5nZXQoJ2NhbGxlZScpLCAoaSkgPT4gcHJlY29tcGlsZVRlbXBsYXRlKGkpKTtcbiAgfVxuXG4gIGlmIChmb3JtYXRPcHRpb25zLnJmYzkzMVN1cHBvcnQgPT09ICdwb2x5ZmlsbGVkJykge1xuICAgIG1heWJlUHJ1bmVJbXBvcnQoc3RhdGUudXRpbCwgdGFyZ2V0LmdldCgnY2FsbGVlJykpO1xuICAgIHN0YXRlLnV0aWwucmVwbGFjZVdpdGgodGFyZ2V0LmdldCgnY2FsbGVlJyksIChpKSA9PiBwcmVjb21waWxlVGVtcGxhdGUoaSkpO1xuICAgIGNvbnZlcnRTdHJpY3RNb2RlKGJhYmVsLCB0YXJnZXQpO1xuICAgIHJlbW92ZUV2YWxBbmRTY29wZSh0YXJnZXQpO1xuICAgIHRhcmdldC5ub2RlLmFyZ3VtZW50cyA9IHRhcmdldC5ub2RlLmFyZ3VtZW50cy5zbGljZSgwLCAyKTtcbiAgICBzdGF0ZS5yZWN1cnNpb25HdWFyZC5hZGQodGFyZ2V0Lm5vZGUpO1xuICAgIHN0YXRlLnV0aWwucmVwbGFjZVdpdGgodGFyZ2V0LCAoaSkgPT5cbiAgICAgIGJhYmVsLnR5cGVzLmNhbGxFeHByZXNzaW9uKGkuaW1wb3J0KCdAZW1iZXIvY29tcG9uZW50JywgJ3NldENvbXBvbmVudFRlbXBsYXRlJyksIFtcbiAgICAgICAgdGFyZ2V0Lm5vZGUsXG4gICAgICAgIGJhY2tpbmdDbGFzcz8ubm9kZSA/P1xuICAgICAgICAgIGJhYmVsLnR5cGVzLmNhbGxFeHByZXNzaW9uKFxuICAgICAgICAgICAgaS5pbXBvcnQoJ0BlbWJlci9jb21wb25lbnQvdGVtcGxhdGUtb25seScsICdkZWZhdWx0JywgJ3RlbXBsYXRlT25seScpLFxuICAgICAgICAgICAgW11cbiAgICAgICAgICApLFxuICAgICAgXSlcbiAgICApO1xuICAgIC8vIHdlIGp1c3Qgd3JhcHBlZCB0aGUgdGFyZ2V0IGNhbGxFeHByZXNzaW9uIGluIHRoZSBjYWxsIHRvXG4gICAgLy8gc2V0Q29tcG9uZW50VGVtcGxhdGUuIEFkanVzdCBgdGFyZ2V0YCBiYWNrIHRvIHBvaW50IGF0IHRoZVxuICAgIC8vIHByZWNvbXBpbGVUZW1wbGF0ZSBjYWxsIGZvciB0aGUgZmluYWwgdXBkYXRlU2NvcGUgYmVsb3cuXG4gICAgLy9cbiAgICB0YXJnZXQgPSB0YXJnZXQuZ2V0KCdhcmd1bWVudHMuMCcpIGFzIE5vZGVQYXRoPHQuQ2FsbEV4cHJlc3Npb24+O1xuICB9XG4gIC8vIFdlIGRlbGliZXJhdGVseSBkbyB1cGRhdGVTY29wZSBhdCB0aGUgZW5kIHNvIHRoYXQgd2hlbiBpdCB1cGRhdGVzXG4gIC8vIHJlZmVyZW5jZXMsIHRob3NlIHJlZmVyZW5jZXMgd2lsbCBwb2ludCB0byB0aGUgYWNjdXJhdGUgcGF0aHMgaW4gdGhlXG4gIC8vIGZpbmFsIEFTVC5cbiAgdXBkYXRlU2NvcGUoYmFiZWwsIHRhcmdldCwgc2NvcGVMb2NhbHMpO1xufVxuXG5mdW5jdGlvbiB0ZW1wbGF0ZUZhY3RvcnlDb25maWcob3B0czogTm9ybWFsaXplZE9wdHMpIHtcbiAgbGV0IG1vZHVsZU5hbWUgPSAnQGVtYmVyL3RlbXBsYXRlLWZhY3RvcnknO1xuICBsZXQgZXhwb3J0TmFtZSA9ICdjcmVhdGVUZW1wbGF0ZUZhY3RvcnknO1xuICBsZXQgb3ZlcnJpZGVzID0gb3B0cy5vdXRwdXRNb2R1bGVPdmVycmlkZXNbbW9kdWxlTmFtZV0/LltleHBvcnROYW1lXTtcbiAgcmV0dXJuIG92ZXJyaWRlc1xuICAgID8geyBleHBvcnROYW1lOiBvdmVycmlkZXNbMF0sIG1vZHVsZU5hbWU6IG92ZXJyaWRlc1sxXSB9XG4gICAgOiB7IGV4cG9ydE5hbWUsIG1vZHVsZU5hbWUgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRTY29wZShiYWJlbDogdHlwZW9mIEJhYmVsLCBsb2NhbHM6IFNjb3BlTG9jYWxzKSB7XG4gIGxldCB0ID0gYmFiZWwudHlwZXM7XG5cbiAgcmV0dXJuIHQuYXJyb3dGdW5jdGlvbkV4cHJlc3Npb24oXG4gICAgW10sXG4gICAgdC5vYmplY3RFeHByZXNzaW9uKFxuICAgICAgbG9jYWxzXG4gICAgICAgIC5lbnRyaWVzKClcbiAgICAgICAgLm1hcCgoW25hbWUsIGlkZW50aWZpZXJdKSA9PlxuICAgICAgICAgIHQub2JqZWN0UHJvcGVydHkodC5pZGVudGlmaWVyKG5hbWUpLCB0LmlkZW50aWZpZXIoaWRlbnRpZmllciksIGZhbHNlLCB0cnVlKVxuICAgICAgICApXG4gICAgKVxuICApO1xufVxuXG4vLyB0aGlzIGlzIHJlc3BvbnNpYmxlIGJvdGggZm9yIGFkanVzdGluZyB0aGUgQVNUIGZvciBvdXIgc2NvcGUgYXJndW1lbnQgKmFuZCpcbi8vIGVuc3VyaW5nIHRoYXQgYmFiZWwncyBzY29wZSBzeXN0ZW0gd2lsbCBzZWUgdGhhdCB0aGVzZSBuZXcgaWRlbnRpZmllcnNcbi8vIHJlZmVyZW5jZSB0aGVpciBiaW5kaW5ncy4gQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tdHlwZXNjcmlwdCBpbiBwYXJ0aWN1bGFyXG4vLyBjYXJlcyBhbiBhd2Z1bCBsb3QgYWJvdXQgd2hldGhlciBhbiBpbXBvcnQgaGFzIHZhbGlkIG5vbi10eXBlIHJlZmVyZW5jZXMsIHNvXG4vLyB0aGVzZSBuZXdseSBpbnRyb2R1Y2QgcmVmZXJlbmNlcyBuZWVkIHRvIGJlIHZhbGlkLlxuZnVuY3Rpb24gdXBkYXRlU2NvcGUoYmFiZWw6IHR5cGVvZiBCYWJlbCwgdGFyZ2V0OiBOb2RlUGF0aDx0LkNhbGxFeHByZXNzaW9uPiwgbG9jYWxzOiBTY29wZUxvY2Fscykge1xuICBsZXQgdCA9IGJhYmVsLnR5cGVzO1xuICBsZXQgc2Vjb25kQXJnID0gdGFyZ2V0LmdldCgnYXJndW1lbnRzLjEnKSBhcyBOb2RlUGF0aDx0Lk9iamVjdEV4cHJlc3Npb24+IHwgdW5kZWZpbmVkO1xuICBpZiAoc2Vjb25kQXJnKSB7XG4gICAgbGV0IHNjb3BlID0gc2Vjb25kQXJnLmdldCgncHJvcGVydGllcycpLmZpbmQoKHApID0+IHtcbiAgICAgIGxldCBrZXkgPSBwLmdldCgna2V5JykgYXMgTm9kZVBhdGg8dC5Ob2RlPjtcbiAgICAgIHJldHVybiBrZXkuaXNJZGVudGlmaWVyKCkgJiYga2V5Lm5vZGUubmFtZSA9PT0gJ3Njb3BlJztcbiAgICB9KTtcbiAgICBpZiAoc2NvcGUpIHtcbiAgICAgIGlmIChsb2NhbHMuaXNFbXB0eSgpKSB7XG4gICAgICAgIHNjb3BlLnJlbW92ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NvcGUuc2V0KCd2YWx1ZScsIGJ1aWxkU2NvcGUoYmFiZWwsIGxvY2FscykpO1xuICAgICAgICAvLyBmdW5ueS1sb29raW5nIG5hbWluZyBoZXJlLCBidXQgaXQgYWN0dWFsbHkgbWFrZXMgc2Vuc2UgYmVjYXVzZSB3ZSdyZVxuICAgICAgICAvLyBjb25uZWN0aW5nIHRoZSBnbGltbWVyIHNjb3BlIHN5c3RlbSB3aXRoIHRoZSBiYWJlbCBzY29wZSBzeXN0ZW0uXG4gICAgICAgIHNjb3BlLnNjb3BlLmNyYXdsKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghbG9jYWxzLmlzRW1wdHkoKSkge1xuICAgICAgc2Vjb25kQXJnLnB1c2hDb250YWluZXIoXG4gICAgICAgICdwcm9wZXJ0aWVzJyxcbiAgICAgICAgdC5vYmplY3RQcm9wZXJ0eSh0LmlkZW50aWZpZXIoJ3Njb3BlJyksIGJ1aWxkU2NvcGUoYmFiZWwsIGxvY2FscykpXG4gICAgICApO1xuICAgICAgKFxuICAgICAgICBzZWNvbmRBcmcuZ2V0KFxuICAgICAgICAgIGBwcm9wZXJ0aWVzLiR7c2Vjb25kQXJnLm5vZGUucHJvcGVydGllcy5sZW5ndGggLSAxfWBcbiAgICAgICAgKSBhcyBOb2RlUGF0aDx0Lk9iamVjdFByb3BlcnR5PlxuICAgICAgKS5zY29wZS5jcmF3bCgpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghbG9jYWxzLmlzRW1wdHkoKSkge1xuICAgIHRhcmdldC5wdXNoQ29udGFpbmVyKFxuICAgICAgJ2FyZ3VtZW50cycsXG4gICAgICB0Lm9iamVjdEV4cHJlc3Npb24oW3Qub2JqZWN0UHJvcGVydHkodC5pZGVudGlmaWVyKCdzY29wZScpLCBidWlsZFNjb3BlKGJhYmVsLCBsb2NhbHMpKV0pXG4gICAgKTtcbiAgICAodGFyZ2V0LmdldCgnYXJndW1lbnRzLjEnKSBhcyBOb2RlUGF0aDx0Lk9iamVjdEV4cHJlc3Npb24+KS5zY29wZS5jcmF3bCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUV2YWxBbmRTY29wZSh0YXJnZXQ6IE5vZGVQYXRoPHQuQ2FsbEV4cHJlc3Npb24+KSB7XG4gIGxldCBzZWNvbmRBcmcgPSB0YXJnZXQuZ2V0KCdhcmd1bWVudHMuMScpIGFzIE5vZGVQYXRoPHQuT2JqZWN0RXhwcmVzc2lvbj4gfCB1bmRlZmluZWQ7XG4gIGlmIChzZWNvbmRBcmcpIHtcbiAgICBsZXQgZXZhbFByb3AgPSBzZWNvbmRBcmcuZ2V0KCdwcm9wZXJ0aWVzJykuZmluZCgocCkgPT4ge1xuICAgICAgbGV0IGtleSA9IHAuZ2V0KCdrZXknKSBhcyBOb2RlUGF0aDx0Lk5vZGU+O1xuICAgICAgcmV0dXJuIGtleS5pc0lkZW50aWZpZXIoKSAmJiBrZXkubm9kZS5uYW1lID09PSAnZXZhbCc7XG4gICAgfSk7XG4gICAgaWYgKGV2YWxQcm9wKSB7XG4gICAgICBldmFsUHJvcC5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBsZXQgY29tcG9uZW50UHJvcCA9IHNlY29uZEFyZy5nZXQoJ3Byb3BlcnRpZXMnKS5maW5kKChwKSA9PiB7XG4gICAgICBsZXQga2V5ID0gcC5nZXQoJ2tleScpIGFzIE5vZGVQYXRoPHQuTm9kZT47XG4gICAgICByZXR1cm4ga2V5LmlzSWRlbnRpZmllcigpICYmIGtleS5ub2RlLm5hbWUgPT09ICdjb21wb25lbnQnO1xuICAgIH0pO1xuICAgIGlmIChjb21wb25lbnRQcm9wKSB7XG4gICAgICBjb21wb25lbnRQcm9wLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBHaXZlbiBhIGNhbGwgdG8gdGVtcGxhdGUoKSwgY29udmVydCBpdHMgXCJzdHJpY3RcIiBhcmd1bWVudCBpbnRvXG4vLyBwcmVjb21waWxlVGVtcGxhdGUncyBcInN0cmljdE1vZGVcIiBhcmd1bWVudC4gVGhleSBkaWZmZXIgaW4gbmFtZSBhbmQgZGVmYXVsdFxuLy8gdmFsdWUuXG5mdW5jdGlvbiBjb252ZXJ0U3RyaWN0TW9kZShiYWJlbDogdHlwZW9mIEJhYmVsLCB0YXJnZXQ6IE5vZGVQYXRoPHQuQ2FsbEV4cHJlc3Npb24+KSB7XG4gIGxldCB0ID0gYmFiZWwudHlwZXM7XG4gIGxldCBzZWNvbmRBcmcgPSB0YXJnZXQuZ2V0KCdhcmd1bWVudHMuMScpIGFzIE5vZGVQYXRoPHQuT2JqZWN0RXhwcmVzc2lvbj4gfCB1bmRlZmluZWQ7XG4gIGlmIChzZWNvbmRBcmcpIHtcbiAgICBsZXQgc3RyaWN0ID0gc2Vjb25kQXJnLmdldCgncHJvcGVydGllcycpLmZpbmQoKHApID0+IHtcbiAgICAgIGxldCBrZXkgPSBwLmdldCgna2V5JykgYXMgTm9kZVBhdGg8dC5Ob2RlPjtcbiAgICAgIHJldHVybiBrZXkuaXNJZGVudGlmaWVyKCkgJiYga2V5Lm5vZGUubmFtZSA9PT0gJ3N0cmljdCc7XG4gICAgfSkgYXMgTm9kZVBhdGg8dC5PYmplY3RQcm9wZXJ0eT47XG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgc3RyaWN0LnNldCgna2V5JywgdC5pZGVudGlmaWVyKCdzdHJpY3RNb2RlJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWNvbmRBcmcucHVzaENvbnRhaW5lcihcbiAgICAgICAgJ3Byb3BlcnRpZXMnLFxuICAgICAgICB0Lm9iamVjdFByb3BlcnR5KHQuaWRlbnRpZmllcignc3RyaWN0TW9kZScpLCB0LmJvb2xlYW5MaXRlcmFsKHRydWUpKVxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LnB1c2hDb250YWluZXIoXG4gICAgICAnYXJndW1lbnRzJyxcbiAgICAgIHQub2JqZWN0RXhwcmVzc2lvbihbdC5vYmplY3RQcm9wZXJ0eSh0LmlkZW50aWZpZXIoJ3N0cmljdE1vZGUnKSwgdC5ib29sZWFuTGl0ZXJhbCh0cnVlKSldKVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVQcnVuZUltcG9ydChcbiAgdXRpbDogSW1wb3J0VXRpbCxcbiAgaWRlbnRpZmllcjogTm9kZVBhdGg8dC5FeHByZXNzaW9uIHwgdC5WOEludHJpbnNpY0lkZW50aWZpZXI+XG4pIHtcbiAgaWYgKCFpZGVudGlmaWVyLmlzSWRlbnRpZmllcigpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBiaW5kaW5nID0gaWRlbnRpZmllci5zY29wZS5nZXRCaW5kaW5nKGlkZW50aWZpZXIubm9kZS5uYW1lKTtcblxuICBpZiAoIWJpbmRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgZm91bmQgPSBiaW5kaW5nLnJlZmVyZW5jZVBhdGhzLmZpbmQoKHBhdGgpID0+IHBhdGgubm9kZSA9PT0gaWRlbnRpZmllci5ub2RlKTtcbiAgaWYgKCFmb3VuZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGJpbmRpbmcucmVmZXJlbmNlUGF0aHMuc3BsaWNlKGJpbmRpbmcucmVmZXJlbmNlUGF0aHMuaW5kZXhPZihmb3VuZCksIDEpO1xuICBiaW5kaW5nLnJlZmVyZW5jZXMtLTtcblxuICBpZiAoYmluZGluZy5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgbGV0IHNwZWNpZmllciA9IGJpbmRpbmcucGF0aDtcbiAgICBpZiAoc3BlY2lmaWVyLmlzSW1wb3J0U3BlY2lmaWVyKCkpIHtcbiAgICAgIGxldCBkZWNsYXJhdGlvbiA9IHNwZWNpZmllci5wYXJlbnRQYXRoIGFzIE5vZGVQYXRoPHQuSW1wb3J0RGVjbGFyYXRpb24+O1xuICAgICAgdXRpbC5yZW1vdmVJbXBvcnQoZGVjbGFyYXRpb24ubm9kZS5zb3VyY2UudmFsdWUsIG5hbWUoc3BlY2lmaWVyLm5vZGUuaW1wb3J0ZWQpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlY29tcGlsZVRlbXBsYXRlKGk6IEltcG9ydGVyKSB7XG4gIHJldHVybiBpLmltcG9ydCgnQGVtYmVyL3RlbXBsYXRlLWNvbXBpbGF0aW9uJywgJ3ByZWNvbXBpbGVUZW1wbGF0ZScpO1xufVxuXG5mdW5jdGlvbiBuYW1lKG5vZGU6IHQuU3RyaW5nTGl0ZXJhbCB8IHQuSWRlbnRpZmllcikge1xuICBpZiAobm9kZS50eXBlID09PSAnU3RyaW5nTGl0ZXJhbCcpIHtcbiAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZS5uYW1lO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1ha2VQbHVnaW48T3B0aW9ucz4oKG9wdGlvbnMpID0+IG9wdGlvbnMpO1xuIl19